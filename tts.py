from pydub import AudioSegment
import os
import argparse
import shutil
parser = argparse.ArgumentParser(prog='Text to Speech', description='Converts text to speech.', epilog='Have fun!')
parser.add_argument("-i", "--input")
parser.add_argument("-v", "--volume", help="Sets output volume, default is 2.0")
parser.add_argument("--decompress", action="store_true", help="Decompress recordings to raw uncompressed wavs instead of mp3s. This takes up a bit more storage but makes generation of long texts multiple times faster. Use this arguement every time you want to use uncompressed training data, otherwise it will default to compressed.")
parser.add_argument("--del-uncompressed", action="store_true", help="Delete uncompressed training data generated by --decompress to save space.")
parser.add_argument("--debug", action="store_true", help="Long debug output.")
args = parser.parse_args()
debug = args.debug
volume="2.0"
if args.volume != None:
	volume=args.volume
try:
	if float(volume) >= 4:
		input("WARNING: With this volume the output file will be VERY LOUD and may damage your ears. I would recommend lowering it. Press enter to continue anyway.")
except:
	print("Invalid volume! Must be a number. 2.0 is default volume.")
	args.input=None
if args.del_uncompressed==True:
	shutil.rmtree("rawrec")
recdir="rec/" #recordings directory
filetype="mp3"
sounds=os.listdir(recdir) #list available recordings in sounds list
if args.decompress==True:
	recdir="rawrec/"
	filetype="wav"
	if os.path.isdir("rawrec")==False:
		os.mkdir("rawrec")
		currentfile=0
		for x in sounds:
			recording=AudioSegment.from_file("rec/"+x)
			recording.export("rawrec/"+os.path.splitext(x)[0]+".wav", format="wav", parameters=["-acodec", "pcm_s16le", "-ar", "44100", "-ac", "2"])
			currentfile+=1
			print(f"Decompressing: {round((currentfile/len(sounds))*100)}%", end='\r')
		print("Done!")
	else:
		print("Uncompressed recordings folder already exists, if you want compress the audio again, use --del-uncompressed.")
	sounds=os.listdir(recdir) #update sounds to new decompressed state
def sound(sound): #Function to load audio from file
	global recdir
	return AudioSegment.from_file(recdir+sound)
def section(x,y): #Function to get specific part of input text using x and y, see comment bellow.
	#x is how many characters we are from the end of the text,
	#y is how many characters we are grabbing, starting from x
	#pos is where we are in the text from the start, aka length-x
	global length
	pos=length-x
	return origtext[pos-y:pos]
if args.input != None:
	origtext="-"+args.input.lower().replace(" ", "-@-")+"-"
	length=len(origtext)
	print(origtext)
	splittext=[]
	x=0
	y=0
	pos=length
	#x is how many characters we are from the end of the text,
	#y is how many characters we are grabbing, starting from x
	#pos is where we are in the text from the start, aka length-x
	while x <= length:
		if pos <= 8:
			y=pos
		else:
			y=8
		found=False
		while y >= 0:
			if debug==True:
				print("x: " +str(x)+", y: "+str(y))
				print(section(x,y))
			if (section(x,y)+"."+filetype) in sounds:
				splittext.append(section(x,y)+"."+filetype) # Add name of decided recording to splittext: the list of recordings that form the final output
				x+=y
				found=True
				break
			y-=1
		if found == False:
			x+=1
	splitttext = splittext.reverse() # reverse the order of the list of letter combinations, changing it from ["est", "t"] to ["t", "est"]
	print(splittext)
	lengthsplit=len(splittext)
	finalsound=AudioSegment.empty()
	y=0
	for x in splittext:
		finalsound += sound(x)
		percent=(str(round((y/lengthsplit)*100))+"%")
		print(f"Generating: {percent}", end='\r')
		y+=1
	finalsound.export("output.mp3", format="mp3", parameters=["-filter:a", "volume="+volume+""])
	print("Done! Find output.mp3 in the program's running directory.")
