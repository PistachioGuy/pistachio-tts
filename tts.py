from pydub import AudioSegment
import os
import argparse
import shutil
import re
parser = argparse.ArgumentParser(prog='Text to Speech', description='Converts text to speech.', formatter_class=argparse.RawDescriptionHelpFormatter, epilog='Example usage:\n  tts.py --decompress -i "The quick brown fox jumped over the lazy dog." ')
parser.add_argument("-i", "--input")
parser.add_argument("-o", "--output", help="Default is tts-output.mp3 in the running directory")
parser.add_argument("-v", "--volume", help="Sets output volume, default is 2.0")
parser.add_argument("--decompress", action="store_true", help="Decompress recordings to raw uncompressed wavs instead of mp3s. This takes up a bit more storage but makes generation of long texts multiple times faster. Use this arguement every time you want to use uncompressed training data, otherwise it will default to compressed.")
parser.add_argument("--del-uncompressed", action="store_true", help="Delete uncompressed training data generated by --decompress to save space.")
parser.add_argument("--debug", action="store_true", help="Long debug output.")
args = parser.parse_args()
debug = args.debug
volume="2.0"
if args.volume != None:
	volume=args.volume
output = os.getcwd()+"/tts-output.mp3"
if args.output != None:
	if os.path.isfile(args.output):
		if input("File already exists. Overwrite? (Y/N)").lower() == "y":
			output=args.output
		else:
			args.input=None
	elif os.path.isdir(args.output):
		output=args.output+"/tts-output.mp3"
	else:
		try:
			with open(args.output, 'w') as fp:
				pass
			output=args.output
		except:
			print("Error: No such directory.")
			args.input=None
if(output[len(output)-4:len(output)])!=".mp3":
	output+=".mp3"
try:
	if float(volume) >= 4:
		input("WARNING: With this volume the output file will be VERY LOUD and may damage your ears. I would recommend lowering it. Press enter to continue anyway.")
except:
	print("Invalid volume! Must be a number. 2.0 is default volume.")
	args.input=None
if args.del_uncompressed==True:
	shutil.rmtree("rawrec")
recdir="rec/" #recordings directory
filetype="mp3"
sounds=os.listdir(recdir) #list available recordings in sounds list
if args.decompress==True:
	recdir="rawrec/"
	filetype="wav"
	if os.path.isdir("rawrec")==False:
		os.mkdir("rawrec")
		y=0
		for x in sounds:
			recording=AudioSegment.from_file("rec/"+x)
			recording.export("rawrec/"+os.path.splitext(x)[0]+".wav", format="wav", parameters=["-acodec", "pcm_s16le", "-ar", "44100", "-ac", "2"])
			y+=1
			print(f"Decompressing: {round((y/len(sounds))*100)}%", end='\r')
		print("\nDone!")
	else:
		print("Uncompressed recordings folder already exists, if you want compress the audio again, use --del-uncompressed.")
	sounds=os.listdir(recdir) #update sounds to new decompressed state
def sound(sound): #Function to load audio from file
	global recdir
	return AudioSegment.from_file(recdir+sound)
def section(x,y): #Function to get specific part of input text using x and y, see comment bellow.
	#x is how many characters we are from the end of the text,
	#y is how many characters we are grabbing, starting from x
	#pos is where we are in the text from the start, aka length-x
	global length
	pos=length-x
	return origtext[pos-y:pos]
if args.input != None:
	origtext="-"+re.sub("[']", "-#-", (re.sub("[^0-9a-z']", " ", args.input.lower()))).replace(" ", "--@--")+"-" # -#- replaces '  so don't becomes don-#-t to match the recording name don-#-t.mp3/wav
	length=len(origtext)
	print(origtext)
	splittext=[]
	x=0
	y=0
	pos=length
	#x is how many characters we are from the end of the text,
	#y is how many characters we are grabbing, starting from x
	#pos is where we are in the text from the start, aka length-x
	while x <= length:
		if pos <= 10:
			y=pos
		else:
			y=10
		found=False
		while y > 0:
			if section(x,y)=="":
				y-=1
				continue
			if debug==True:
				print("x: " +str(x)+", y: "+str(y))
				print(section(x,y))
			currentfile=section(x,y)+"."+filetype #in the next line we are checking to see if the filename in this variable exists in the recordings, to see if a certain set of characters has a recording.
			currentfilewithoutlastchar =section(x,y)[:-1]+"."+filetype
			currentfilewithoutlast2chars =section(x,y)[:-2]+"."+filetype
			if (currentfile in sounds):#check if filename exists
				splittext.append(currentfile) # Add name of decided recording to splittext: the list of recordings that form the final output
				x+=y
				found=True
				break
			elif (section(x,y)[-2:] == "--") and (currentfilewithoutlast2chars in sounds): #if filename from last if statement doesn't exist, check if the last character is "-". If so, check if it exists without the "-" eg. does ated-.mp3 exist? no, does ated.mp3 exist, yes. That way it won't prioritize ed-.mp3 and do a.mp3 t.mp3 ed-.mp3
				splittext.append(currentfilewithoutlast2chars) # Add name of decided recording to splittext: the list of recordings that form the final output
				x+=y
				found=True
				break
			elif (section(x,y)[-1] == "-") and (currentfilewithoutlastchar in sounds): #if filename from last if statement doesn't exist, check if the last character is "-". If so, check if it exists without the "-" eg. does ated-.mp3 exist? no, does ated.mp3 exist, yes. That way it won't prioritize ed-.mp3 and do a.mp3 t.mp3 ed-.mp3
				splittext.append(currentfilewithoutlastchar) # Add name of decided recording to splittext: the list of recordings that form the final output
				x+=y
				found=True
				break
			y-=1
		if found == False:
			x+=1
	splitttext = splittext.reverse() # reverse the order of the list of letter combinations, changing it from ["est", "t"] to ["t", "est"]
	print(splittext)
	lengthsplit=len(splittext)
	finalsound=AudioSegment.empty()
	y=0
	for x in splittext:
		finalsound += sound(x)
		percent=(str(round((y/lengthsplit)*100))+"%")
		print(f"Generating: {percent}", end='\r')
		y+=1
	finalsound.export(output, format="mp3", parameters=["-filter:a", "volume="+volume+""])
	print("Done! Find output.mp3 in " + output)
